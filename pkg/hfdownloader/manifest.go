// Copyright 2025
// SPDX-License-Identifier: Apache-2.0

package hfdownloader

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// ManifestFilename is the standard name for manifest files.
const ManifestFilename = "hfd.yaml"

// DownloadManifest captures the complete record of a download job.
// This file is written to the friendly view root (e.g., models/Owner/Repo/hfd.yaml)
// and contains all information needed to understand and reproduce the download.
type DownloadManifest struct {
	// Metadata
	Version string `yaml:"version" json:"version"` // Manifest format version

	// Repository info
	Type     string `yaml:"type" json:"type"`           // "model" or "dataset"
	Repo     string `yaml:"repo" json:"repo"`           // "owner/name"
	Branch   string `yaml:"branch" json:"branch"`       // Branch name (usually "main")
	Commit   string `yaml:"commit" json:"commit"`       // Commit hash
	RepoPath string `yaml:"repo_path" json:"repo_path"` // Relative path to hub cache (e.g., "hub/models--owner--repo")

	// Timing
	StartedAt   time.Time `yaml:"started_at" json:"started_at"`     // When download started
	CompletedAt time.Time `yaml:"completed_at" json:"completed_at"` // When download completed

	// CLI command used (token stripped for security)
	Command string `yaml:"command" json:"command"`

	// Results
	TotalSize  int64          `yaml:"total_size" json:"total_size"`   // Total bytes downloaded
	TotalFiles int            `yaml:"total_files" json:"total_files"` // Number of files
	Files      []ManifestFile `yaml:"files" json:"files"`
}

// ManifestFile represents a single file in the manifest.
// The Blob field contains the relative path from the repo directory to the blob,
// making it easy for automation scripts to locate and copy files.
type ManifestFile struct {
	Name string `yaml:"name" json:"name"` // Original filename (e.g., "model.Q4_K_M.gguf")
	Blob string `yaml:"blob" json:"blob"` // Relative path to blob (e.g., "blobs/abc123...")
	Size int64  `yaml:"size" json:"size"` // File size in bytes
	LFS  bool   `yaml:"lfs" json:"lfs"`   // Is LFS file
}

// ManifestBuilder helps construct a manifest during download.
type ManifestBuilder struct {
	manifest  *DownloadManifest
	startTime time.Time
}

// NewManifestBuilder creates a new manifest builder for a download job.
func NewManifestBuilder(job Job, command string) *ManifestBuilder {
	repoType := "model"
	if job.IsDataset {
		repoType = "dataset"
	}

	branch := job.Revision
	if branch == "" {
		branch = "main"
	}

	// Build repo path (relative to cache root)
	repoPath := "hub/" + RepoTypeName(job.IsDataset) + "--" + strings.ReplaceAll(job.Repo, "/", "--")

	return &ManifestBuilder{
		startTime: time.Now().UTC(),
		manifest: &DownloadManifest{
			Version:   "1.0",
			Type:      repoType,
			Repo:      job.Repo,
			Branch:    branch,
			RepoPath:  repoPath,
			StartedAt: time.Now().UTC(),
			Command:   command,
			Files:     []ManifestFile{},
		},
	}
}

// SetCommit sets the commit hash.
func (b *ManifestBuilder) SetCommit(commit string) {
	b.manifest.Commit = commit
}

// AddFile adds a file to the manifest.
func (b *ManifestBuilder) AddFile(name, blobHash string, size int64, isLFS bool) {
	b.manifest.Files = append(b.manifest.Files, ManifestFile{
		Name: name,
		Blob: "blobs/" + blobHash,
		Size: size,
		LFS:  isLFS,
	})
	b.manifest.TotalSize += size
	b.manifest.TotalFiles++
}

// Build finalizes the manifest with completion time.
func (b *ManifestBuilder) Build() *DownloadManifest {
	b.manifest.CompletedAt = time.Now().UTC()
	return b.manifest
}

// Write writes the manifest to the friendly view directory.
func (m *DownloadManifest) Write(friendlyPath string) (string, error) {
	manifestPath := filepath.Join(friendlyPath, ManifestFilename)

	// Ensure directory exists
	if err := os.MkdirAll(friendlyPath, 0o755); err != nil {
		return "", fmt.Errorf("create manifest dir: %w", err)
	}

	data, err := yaml.Marshal(m)
	if err != nil {
		return "", fmt.Errorf("marshal manifest: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# HuggingFace %s: %s\n", m.Type, m.Repo)
	header += fmt.Sprintf("# Downloaded: %s\n", m.CompletedAt.Format(time.RFC3339))
	header += "# Generated by hfdownloader\n\n"
	content := header + string(data)

	if err := os.WriteFile(manifestPath, []byte(content), 0o644); err != nil {
		return "", fmt.Errorf("write manifest: %w", err)
	}

	return manifestPath, nil
}

// GenerateManifestFromCache creates a manifest by scanning an existing repo in the cache.
// This is used by the rebuild command to generate manifests for repos that were
// downloaded without manifest support or by the official HuggingFace Python library.
func (c *HFCache) GenerateManifestFromCache(repoDir *RepoDir) (*DownloadManifest, error) {
	repoType := "model"
	if repoDir.Type() == RepoTypeDataset {
		repoType = "dataset"
	}

	// Find current commit from refs
	var commit, branch string
	for _, ref := range []string{"main", "master"} {
		cm, err := repoDir.ReadRef(ref)
		if err == nil && cm != "" {
			commit = cm
			branch = ref
			break
		}
	}

	if commit == "" {
		snapshots, err := repoDir.ListSnapshots()
		if err != nil || len(snapshots) == 0 {
			return nil, fmt.Errorf("no commit found for %s", repoDir.RepoID())
		}
		commit = snapshots[0]
		branch = "unknown"
	}

	// Get files from snapshot
	snapshotDir := repoDir.SnapshotDir(commit)
	if _, err := os.Stat(snapshotDir); errors.Is(err, os.ErrNotExist) {
		return nil, fmt.Errorf("snapshot not found for %s", repoDir.RepoID())
	}

	// Build repo path (relative to cache root)
	// Format: hub/{type}--{owner}--{name}
	typeName := "models"
	if repoDir.Type() == RepoTypeDataset {
		typeName = "datasets"
	}
	repoPath := "hub/" + typeName + "--" + strings.ReplaceAll(repoDir.RepoID(), "/", "--")

	var files []ManifestFile
	var totalSize int64

	err := filepath.Walk(snapshotDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}

		relPath, err := filepath.Rel(snapshotDir, path)
		if err != nil {
			return nil
		}

		var size int64
		var blobHash string
		var isLFS bool

		// Snapshot files are symlinks to blobs
		if info.Mode()&os.ModeSymlink != 0 {
			target, err := os.Readlink(path)
			if err == nil && strings.Contains(target, "blobs/") {
				parts := strings.Split(target, "blobs/")
				if len(parts) > 1 {
					blobHash = parts[1]
				}
				actualPath := filepath.Join(filepath.Dir(path), target)
				if fi, err := os.Stat(actualPath); err == nil {
					size = fi.Size()
					isLFS = size > 10*1024 // Heuristic: LFS files are typically > 10KB
				}
			}
		} else {
			size = info.Size()
		}

		totalSize += size
		files = append(files, ManifestFile{
			Name: relPath,
			Blob: "blobs/" + blobHash,
			Size: size,
			LFS:  isLFS,
		})

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("walk snapshot: %w", err)
	}

	// Try to preserve timing from existing manifest if available
	existingManifest, _ := ReadManifest(filepath.Join(repoDir.FriendlyPath(), ManifestFilename))
	startedAt := time.Now().UTC()
	completedAt := time.Now().UTC()
	command := "(regenerated from cache)"
	if existingManifest != nil {
		startedAt = existingManifest.StartedAt
		completedAt = existingManifest.CompletedAt
		command = existingManifest.Command
	}

	return &DownloadManifest{
		Version:     "1.0",
		Type:        repoType,
		Repo:        repoDir.RepoID(),
		Branch:      branch,
		Commit:      commit,
		RepoPath:    repoPath,
		StartedAt:   startedAt,
		CompletedAt: completedAt,
		Command:     command,
		TotalSize:   totalSize,
		TotalFiles:  len(files),
		Files:       files,
	}, nil
}

// ReadManifest reads a manifest from a file.
func ReadManifest(path string) (*DownloadManifest, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var manifest DownloadManifest
	if err := yaml.Unmarshal(data, &manifest); err != nil {
		return nil, err
	}

	return &manifest, nil
}

// WriteRepoManifest generates and writes a manifest for a repo from the cache.
func (c *HFCache) WriteRepoManifest(repoDir *RepoDir) (string, error) {
	manifest, err := c.GenerateManifestFromCache(repoDir)
	if err != nil {
		return "", err
	}
	return manifest.Write(repoDir.FriendlyPath())
}

// WriteAllManifests writes manifests for all repos in the cache.
func (c *HFCache) WriteAllManifests() (int, []error) {
	repos, err := c.ListRepos()
	if err != nil {
		return 0, []error{fmt.Errorf("list repos: %w", err)}
	}

	var written int
	var errs []error

	for _, repoDir := range repos {
		_, err := c.WriteRepoManifest(repoDir)
		if err != nil {
			errs = append(errs, fmt.Errorf("%s: %w", repoDir.RepoID(), err))
			continue
		}
		written++
	}

	return written, errs
}

// RepoTypeName returns the type name prefix for repo directories.
func RepoTypeName(isDataset bool) string {
	if isDataset {
		return "datasets"
	}
	return "models"
}
